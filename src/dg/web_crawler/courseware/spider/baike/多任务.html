<html><body><div _class='url'>http://baike.baidu.com/view/757238.htm</div><div _class=title>多任务</div><div _class="content"><div>多任务处理是指用户可以在同一时间内运行多个应用程序,每个应用程序被称作一个任务.Linux、windows就是支持多任务的操作系统,比起单任务系统它的功能增强了许多。</div><div>当多任务操作系统使用某种任务调度策略允许两个或更多进程并发共享一个处理器时，事实上处理器在某一时刻只会给一件任务提供服务。因为任务调度机制保证不同任务之间的切换速度十分迅速，因此给人多个任务同时运行的错觉。多任务系统中有3个功能单位：任务、进程和线程。</div><div>Windows是当今流行的多任务操作系统,其多任务处理可分为两类:协同式多任务和抢 先式多任务处理模式。使用协同式多任[1] 
务处理模式,CPU的分配直接由应用程序决定,所以系统性能好坏取决于应用程序设计好坏。而运行抢先式多任务处理模式,各进程占用CPU的时间由系统调度程序决定,当调度程序检测出有比当前任务优先级更高的程序事件后,暂停当前任务并将CPU时间分配给优先级更高的进程。所有的Win16应用程序都在同一台虚拟机上运行,各程序之间采用的是协同式多任务处理。每个Win32应用程序和MS-DOS应用程序都具有自己专用的虚拟机,其进程按抢先式多任务处理方式运行。</div><div>Windows多任务处理采用的是被称为虚拟机(Virtual Machine)的技术。虚拟机实际上指的是由Windows在内存中创建的逻辑微机，由它来运行应用程序。当Windows接受到由鼠标器、键盘、定时器信号或某些I/O操作产生的"事件"后，为该任务分配CPU时间。每个任务使用由Windows分配的短暂的时间片(Timeslice)轮流使用CPU,由于CPU对每个时间片的处理速度非常快，在用户看来好像这些任务在同时执行。</div><div>Windows中的多任务调度策略 Windows中调度的任务有两种状态:运行状态和等待状态。正在运行的任务处于运行状态,当该任务把CPU控制权交给其他任务后,就被置为等待状态。为了便于任务调度和保存每个任务运行的参数,Windows在装载应用程序时,由LoadModule()函数创建一任务数据库[1] 
(简称TDB),该任务数据库在内存中是以链表的形式存在,TDB链表中的结点记下了每个任务切换时的堆栈指针、中断处理程序地址及此任务对应的模块句柄和实例句柄等。Windows就是根据TDB链表中存放的各个任务的数据信息来完成任务调度的。 对Windows而言,CPU属于临界资源,在某一时刻只有一个任务独占CPU。为了合理分配CPU,提高系统的性能,Windows根据任务是否存在等待事件来进行任务调度。如果当前任务没有事件可供处理,那么就应该把控制权交给其他具有等待事件的任务。为了记录每个任务的等待事件个数,在TDB链表中,为每个任务建立一个事件计数器(TDB偏移6处的值),系统调度程序就是根据该计数器来进行任务调度。我们可以通过Windows中未公开的核心函数PostEvent()把指定任务的事件计数器值增1,人为地伪造一个事件,引起相应的任务被唤醒。 当有多个任务都具有等待事件时,Windows采用的最高优先级(HPF)算法进行调度。为此Windows定义了任务的优先权值:范围从-32到+15,任务的优先权值越小,它的优先级就越高,其任务结点在TDB链表中的位置也越靠前。而在实际应用中,绝大多数Windows应用程序的优先值都是0,若优先权值相同,则按先来先服务的原则进行。任务的优先权值只对具有等待事件的任务生效,如果一个任务没有等待事件,即使优先权再高,也不会被调度。 若当前任务所分配的时间片用完或当前任务再无等待事件,任务调度程序就要释放当前任务的控制权,把控制权交给已选中的可调度任务。但在WindowsAPI中并没直接公开这样一个函数,许多具有释放控制权功能的函数都被隐藏在GetMessage()或PeekMessage()这样的消息函数中,当应用程序在消息环中没有消息可供接收时,它就会把控制权交给别的任务,以防止当前任务进入死循环。当前任务释放控制权以后,如果没一个任务被调度程序选中,调度程序就会使Windows进入系统空闲状态,相应的电源管理软件就会使整个系统处于低能耗的睡眠状态,直至有任务被唤醒而重新开始正常运转。</div><div>使用抢先式多任务工作方式使得32位Windows应用程序和DOS应用程序能够平等地共享C PU资源，消除了Windows 3.X单个任务执行时独占系统资源的现象，提高了应用程序的执行效率和速度，也使用户有可能摆脱前文所提到的困境。在Windows 95运行时，用户可以根据鼠标指针的变化了解各个任务所处的状态。当鼠标指针在某个窗口变成沙漏指针时，用户不能对该窗口进行操作。但可以把鼠标指针移到该窗口以外，这时鼠标指针有可能变成箭头或箭头与沙漏的组合，表示用户此时可以进行抢先操作而不必像在Windows 3.X中那样处在无奈的等待中。当发现某个任务意外死锁或终止时，我们可以利用Windows 95的这种抢先式多任务的特性，先将其它任务正常结束，再想办法处理出了问题的程序，以减少工作损失。在Windows 95中，对出现意外错误的程序，可以使用Ctrl+Alt+Del组合键调出"关闭程序窗口，选中该程序后再用"结束任务"操作将它关闭。但要小心，不可轻易再次击Ctrl+Alt+D el组合键，以避免重新启动机器造成信息丢失。</div><div>实时多任务操作系统（RTOS）是嵌入式应用软件的基础和开发平台，它是根据操作系统的工作特性而言的。实时是指物理进程的真实时间。实时操作系统是指具有实时性，能支持实时控制系统工作的操作系统。首要任务是调度一切可利用的资源完成实时控制任务，其次才着眼于提高计算机系统的使用效率，重要特点是要满足对时间的限制和要求。目前在中国大多数嵌入式软件开发还是基于处理器直接编写，没有采用商品化的RTOS，不能将系统软件和应用软件分开处理。RTOS是一段嵌入在目标代码中的软件，用户的其它应用程序都建立在RTOS之上。不但如此，RTOS还是一个可靠性和可信性很高的实时内核，将CPU时间、中断、I/O、定时器等资源都包装起来，留给用户一个标准的API，并根据各个任务的优先级，合理地在不同任务之间分配CPU时间。</div><div>RTOS是针对不同处理器优化设计的高效率实时多任务内核，优秀商品化的RTOS可以面对几十个系列的嵌入式处理器MPU、MCU、DSP、SOC等提供类同的API接口，这是RTOS基于设备独立的应用程序开发基础。因此基于RTOS上的C语言程序具有极大的可移植性。据专家测算，优秀RTOS上跨处理器平台的程序移植只需要修改1~5%的内容。在RTOS基础上可以编写出各种硬件驱动程序、专家库函数、行业库函数、产品库函数，和通用性的应用程序一起，可以作为产品销售，促进行业内的知识产权交流，因此RTOS又是一个软件开发平台。</div><div>RTOS是嵌入式系统的软件开发平台，RTOS最关键的部分是实时多任务内核，它的基本功能包括任务管理、定时器管理、存储器管理、资源管理、事件管理、系统管理、消息管理、队列管理、旗语管理等,这些管理功能是通过内核服务函数形式交给用户调用的，也就是RTOS的API。RTOS的引入，解决了嵌入式软件开发标准化的难题。随着嵌入式系统中软件比重不断上升、应用程序越来越大，对开发人员、应用程序接口、程序档案的组织管理成为一个大的课题。引入RTOS相当于引入了一种新的管理模式，对于开发单位和开发人员都是一个提高。</div><div>基于RTOS开发出的程序，具有较高的可移植性，实现90%以上设备独立，一些成熟的通用程序可以作为专家库函数产品推向社会。嵌入式软件的函数化、产品化能够促进行业交流以及社会分工专业化，减少重复劳动，提高知识创新的效率。</div><div>嵌入式工业的基础是以应用为中心的芯片设计和面向应用的软件开发。实时多任务操作系统(RTOS)进入嵌入式工业的意义不亚于历史上机械工业采用三视图的贡献，对嵌入式软件的标准化和加速知识创新是一个里程碑。</div></div></body></html>